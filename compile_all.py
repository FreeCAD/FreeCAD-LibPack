#!/bin/python3

# SPDX-License-Identifier: LGPL-2.1-or-later

# Every package has its own compilation and installation idiosyncrasies, so we have to use a custom
# build script for each one.

from diff_match_patch import diff_match_patch
from enum import Enum
import os
import pathlib
import platform
import re
import shutil
import subprocess
import sys


class BuildMode(Enum):
    DEBUG = 1
    RELEASE = 2

    def __str__(self) -> str:
        if self == BuildMode.DEBUG:
            return "Debug"
        elif self == BuildMode.RELEASE:
            return "Release"
        else:
            return "Unknown"


def patch_single_file(filename, patch_data) -> None:
    with open(filename, "r", encoding="utf-8") as f:
        original_data = f.read()
    dmp = diff_match_patch()
    patches = dmp.patch_fromText(patch_data)
    new_text, applied = dmp.patch_apply(patches, original_data)
    if not all(applied):
        print(f"ERROR: Failed to apply some patches to {filename}")
        # TODO: Someday actually print out what patches failed?
        exit(1)
    with open (filename, "w", encoding="utf-8") as f:
        f.write(new_text)


def split_patch_data(patch_data: str) -> list[dict[str, str]]:
    filename_regex = re.compile("@@@ ([^@]*) @@@\n")
    split_data = re.split(filename_regex, patch_data)
    result = []
    for index, entry in enumerate(split_data):
        if index == 0:
            if entry != "":
                print("ERROR: Bad patch file, must start with @@@ filename @@@")
                exit(1)
            continue
        if index % 2 == 1:
            result.append({"file": entry})
        else:
            result[-1]["data"] = entry
    return result


def apply_patch(patch_file_path: str) -> None:
    """ Apply a patch that was generated by the generate_patch.py script """
    # Path is relative to *this* file, not our working directory
    absolute_path = os.path.join(pathlib.Path(__file__).parent.absolute(), patch_file_path)
    with open(absolute_path, "r", encoding="utf-8") as f:
        patch_data = f.read()
    patches = split_patch_data(patch_data)
    for patch in patches:
        patch_single_file(patch["file"], patch["data"])


def patch_files(patches: list[str]) -> None:
    """ Given a list of patches, apply them sequentially in the current working directory. The patches themselves are
    expected to be given as paths relative to **this** Python script file"""
    for patch in patches:
        start = len("patches/")
        print(f"Applying patch {patch[start:]}")
        apply_patch(patch)

class Compiler:
    def __init__(self, config, mode, bison_path, skip_existing: bool = False):
        self.config = config
        self.mode = mode
        self.bison_path = bison_path
        self.base_dir = os.getcwd()
        self.skip_existing = skip_existing
        libpack_dir = "LibPack-{}-v{}-{}".format(
            config["FreeCAD-version"],
            config["LibPack-version"],
            str(mode),
        )
        self.install_dir = os.path.join(os.getcwd(), libpack_dir)
        self.init_script = None

    def get_cmake_options(self) -> list[str]:
        """ Get a comprehensive list of cMake options that can be used in any cMake build. Not all options apply
        to all builds, but none conflict. """
        return [
            f"-DBUILD_TESTS=No",
            f"-DBUILD_EXAMPLES=No",
            f"-DBUILD_DOCS=No",
            f"-DBUILD_SHARED=Yes",
            f"-DCMAKE_INSTALL_PATH={self.install_dir}",
            f"-DCMAKE_INSTALL_PREFIX={self.install_dir}",
            f"-DPython_ROOT_DIR={self.install_dir}/bin",
            f"-DBOOST_ROOT={self.install_dir}",
            f"-DBOOST_INCLUDE_DIR={self.install_dir}/include",
            f"-DQt6_DIR={self.install_dir}/lib/cmake/Qt6",
            f"-DCoin_DIR={self.install_dir}/lib/cmake/Coin-4.0.1",
            f"-DSWIG_EXECUTABLE={self.install_dir}/bin/swig" + ".exe" if sys.platform.startswith("win32") else "",
            f"-DZLIB_INCLUDE_DIR={self.install_dir}/include",
            f"-DZLIB_LIBRARY_RELEASE={self.install_dir}/lib/zlib." + "lib" if sys.platform.startswith("win32") else "a",
            f"-DHarfBuzz_DIR={self.install_dir}/lib/cmake/",
            f"-DZLIB_DIR={self.install_dir}/lib/cmake/",
            f"-DBZIP2_DIR={self.install_dir}/lib/cmake/",
            f"-DPCRE2_LIBRARY={self.install_dir}/lib/pcre2-8.lib",
            f"-DCMAKE_CXX_FLAGS=-I{self.install_dir}/include",
            f"-DBISON_EXECUTABLE={self.bison_path}"
        ]

    def compile_all(self):
        for item in self.config["content"]:
            # All build methods are named using "build_XXX" where XXX is the name of the package in the config file
            print(f"Building {item['name']} in {self.mode} mode")
            os.chdir(item["name"])
            if "patches" in item:
                patch_files(item["patches"])
            build_function_name = "build_" + item["name"]
            build_function = getattr(self, build_function_name)
            build_function(item)
            os.chdir(self.base_dir)

    def build_nonexistent(self, _=None):
        """Used for automated testing to allow easy Mock injection"""

    def build_python(self, _=None):
        """ NOTE: This doesn't install correctly, so should not be used at this time... install Python manually """
        if sys.platform.startswith("win32"):
            expected_exe_path = os.path.join(self.install_dir, "bin", "python.exe")
            if self.skip_existing and os.path.exists(expected_exe_path):
                print("Not rebuilding, instead just using existing Python in the LibPack installation path")
                return
            try:
                arch = "x64" if platform.machine() == "AMD64" else "ARM64"
                path = "amd64" if platform.machine() == "AMD64" else "arm64"
                subprocess.run(
                    [
                        "PCbuild\\build.bat",
                        "-p",
                        arch,
                        "-c",
                        str(self.mode),
                    ],
                    check=True,
                    capture_output=True,
                )
            except subprocess.CalledProcessError as e:
                print("Python build failed")
                print(e.output.decode("utf-8"))
                exit(e.returncode)
            bin_dir = os.path.join(self.install_dir, "bin")
            lib_dir = os.path.join(bin_dir, "Lib")
            inc_dir = os.path.join(bin_dir, "Include")
            os.makedirs(bin_dir, exist_ok=True)
            os.makedirs(lib_dir, exist_ok=True)
            os.makedirs(bin_dir, exist_ok=True)
            shutil.copytree(f"PCBuild\\{path}", bin_dir, dirs_exist_ok=True)
            shutil.copytree(f"Lib", lib_dir, dirs_exist_ok=True)
            shutil.copytree(f"Include", inc_dir, dirs_exist_ok=True)
        else:
            raise NotImplemented(
                "Non-Windows compilation of Python is not implemented yet"
            )

    def get_python_version(self) -> str:
        path_to_python = os.path.join(self.install_dir, "bin", "python")
        if sys.platform.startswith("win32"):
            path_to_python += ".exe"
        try:
            result = subprocess.run([path_to_python, "--version"], capture_output=True, check=True)
            _, _, version_number = result.stdout.decode("utf-8").strip().partition(" ")
            components = version_number.split(".")
            python_version = f"{components[0]}.{components[1]}"
            return python_version
        except subprocess.CalledProcessError as e:
            print("ERROR: Failed to run LibPack's Python executable")
            print(e.output.decode("utf-8"))
            exit(1)

    def build_qt(self, options: dict):
        """Doesn't really "build" Qt, just copies the pre-compiled libraries from the configured path"""
        qt_dir = options["install-directory"]
        if self.skip_existing:
            if os.path.exists(os.path.join(self.install_dir, "metatypes")):
                print("Not re-copying, instead just using existing Qt in the LibPack installation path")
                return
        if not os.path.exists(qt_dir):
            print(f"Error: specified Qt installation path does not exist ({qt_dir})")
            exit(1)
        shutil.copytree(qt_dir, self.install_dir, dirs_exist_ok=True)

    def build_boost(self, _=None):
        """ Builds boost shared libraries and installs libraries and headers """
        if self.skip_existing:
            if os.path.exists(os.path.join(self.install_dir, "include", "boost")):
                print("Not rebuilding boost, it is already in the LibPack")
                return
        # Boost uses a custom build system and needs a config file to find our Python
        with open(os.path.join("tools", "build", "src", "user-config.jam"), "w", encoding="utf-8") as user_config:
            exe = os.path.join(self.install_dir, "bin", "python")
            if sys.platform.startswith("win32"):
                exe += ".exe"
            inc_dir = os.path.join(self.install_dir, "bin", "Include")
            lib_dir = os.path.join(self.install_dir, "bin", "Lib")
            python_version = self.get_python_version()
            print(f"Building boost-python with Python {python_version}")
            user_config.write(f'using python : {python_version} : "{exe}" : "{inc_dir}" : "{lib_dir}"  ;\n')
        try:
            subprocess.run(["bootstrap.bat"], capture_output=True, check=True)
            subprocess.run(["b2", f"variant={str(self.mode).lower()}"], check=True, capture_output=True)
            shutil.copytree(os.path.join("stage", "lib"), os.path.join(self.install_dir, "lib"), dirs_exist_ok=True)
            shutil.copytree("boost", os.path.join(self.install_dir, "include", "boost"),
                            dirs_exist_ok=True)
        except subprocess.CalledProcessError as e:
            print("Error: failed to build boost")
            print(e.output.decode("utf-8"))
            exit(e.returncode)

    def _build_standard_cmake(self):
        build_dir = "build-" + str(self.mode).lower()
        if not os.path.exists(build_dir):
            os.mkdir(build_dir)
        os.chdir(build_dir)

        cmake_setup_options = ["cmake"]
        cmake_setup_options.extend(self.get_cmake_options())
        cmake_setup_options.append("..")
        cmake_build_options = ["cmake", "--build", ".", "--config", str(self.mode), "--parallel"]
        cmake_install_options = ["cmake", "--install", "."]
        try:
            subprocess.run(cmake_setup_options, check=True, capture_output=True)
            subprocess.run(cmake_build_options, check=True, capture_output=True)
            subprocess.run(cmake_install_options, check=True, capture_output=True)
        except subprocess.CalledProcessError as e:
            print("ERROR: Build failed!")
            print(e.output.decode("utf-8"))
            exit(e.returncode)

    def build_coin(self, _=None):
        """ Builds and installs Coin using standard CMake settings """
        if self.skip_existing:
            if os.path.exists(os.path.join(self.install_dir, "share", "Coin")):
                print("Not rebuilding Coin, it is already in the LibPack")
                return
        self._build_standard_cmake()

    def build_quarter(self, _=None):
        """ Builds and installs Quarter using standard CMake settings """
        if self.skip_existing:
            if os.path.exists(os.path.join(self.install_dir, "include", "Quarter")):
                print("Not rebuilding Coin, it is already in the LibPack")
                return
        self._build_standard_cmake()

    def build_zlib(self, _=None):
        if self.skip_existing:
            if os.path.exists(os.path.join(self.install_dir, "include", "zlib.h")):
                print("Not rebuilding zlib, it is already in the LibPack")
                return
        self._build_standard_cmake()

    def build_bzip2(self, _= None):
        """ The version of BZip2 in widespread use (1.0.8, the most recent official release) do not yet use cMake """
        if self.skip_existing:
            if os.path.exists(os.path.join(self.install_dir, "include", "bzlib.h")):
                print("Not rebuilding zlib, it is already in the LibPack")
                return
        if sys.platform.startswith("win32"):
            args = [self.init_script, "&", "nmake","/f", "makefile.msc"]
            try:
                subprocess.run(args, check=True, capture_output=True)
                shutil.copyfile("libbz2.lib",os.path.join(self.install_dir, "lib", "libbz2.lib"))
                shutil.copyfile("bzlib.h",os.path.join(self.install_dir, "include", "bzlib.h"))
                shutil.copyfile("bzlib_private.h",os.path.join(self.install_dir, "include", "bzlib_private.h"))
            except subprocess.CalledProcessError as e:
                print("ERROR: Failed to build bzip2 using nmake")
                print(e.output.decode("utf-8"))
                exit(1)
        else:
            raise NotImplemented(
                "Non-Windows compilation of bzip2 is not implemented yet"
            )

    def build_pcre2(self, _=None):
        if self.skip_existing:
            if os.path.exists(os.path.join(self.install_dir, "include", "pcre2.h")):
                print("Not rebuilding pcre2, it is already in the LibPack")
                return
        self._build_standard_cmake()

    def build_swig(self, _=None):
        if self.skip_existing:
            if os.path.exists(os.path.join(self.install_dir, "bin", "swig") + ".exe" if sys.platform.startswith("win32") else ""):
                print("Not rebuilding SWIG, it is already in the LibPack")
                return
        self._build_standard_cmake()

    def build_pivy(self, _=None):
        self._build_standard_cmake()
