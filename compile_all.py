#!/bin/python3

# SPDX-License-Identifier: LGPL-2.1-or-later

# Every package has its own compilation and installation idiosyncrasies, so we have to use a custom
# build script for each one.

from diff_match_patch import diff_match_patch
from enum import Enum
import os
import pathlib
import platform
import re
import shutil
import subprocess
import stat
import sys


class BuildMode(Enum):
    DEBUG = 1
    RELEASE = 2

    def __str__(self) -> str:
        if self == BuildMode.DEBUG:
            return "Debug"
        elif self == BuildMode.RELEASE:
            return "Release"
        else:
            return "Unknown"


def remove_readonly(func, path, _) -> None:
    """Remove a read-only file."""

    os.chmod(path, stat.S_IWRITE)
    func(path)


def patch_single_file(filename, patch_data) -> None:
    with open(filename, "r", encoding="utf-8") as f:
        original_data = f.read()
    dmp = diff_match_patch()
    patches = dmp.patch_fromText(patch_data)
    new_text, applied = dmp.patch_apply(patches, original_data)
    if not all(applied):
        print(f"ERROR: Failed to apply some patches to {filename}")
        # TODO: Someday actually print out what patches failed?
        exit(1)
    with open(filename, "w", encoding="utf-8") as f:
        f.write(new_text)


def split_patch_data(patch_data: str) -> list[dict[str, str]]:
    filename_regex = re.compile("@@@ ([^@]*) @@@\n")
    split_data = re.split(filename_regex, patch_data)
    result = []
    for index, entry in enumerate(split_data):
        if index == 0:
            if entry != "":
                print("ERROR: Bad patch file, must start with @@@ filename @@@")
                exit(1)
            continue
        if index % 2 == 1:
            result.append({"file": entry})
        else:
            result[-1]["data"] = entry
    return result


def apply_patch(patch_file_path: str) -> None:
    """ Apply a patch that was generated by the generate_patch.py script """
    # Path is relative to *this* file, not our working directory
    absolute_path = os.path.join(pathlib.Path(__file__).parent.absolute(), patch_file_path)
    with open(absolute_path, "r", encoding="utf-8") as f:
        patch_data = f.read()
    patches = split_patch_data(patch_data)
    for patch in patches:
        patch_single_file(patch["file"], patch["data"])


def patch_files(patches: list[str]) -> None:
    """ Given a list of patches, apply them sequentially in the current working directory. The patches themselves are
    expected to be given as paths relative to **this** Python script file"""
    for patch in patches:
        start = len("patches/")
        print(f"  Applying patch {patch[start:]}")
        apply_patch(patch)


def libpack_dir(config: dict):
    lp_dir = "LibPack-{}-v{}".format(
        config["FreeCAD-version"],
        config["LibPack-version"],
    )
    return os.path.join(os.path.dirname(__file__), "working", lp_dir)


class Compiler:
    def __init__(self, config, bison_path, skip_existing: bool = False):
        self.config = config
        self.bison_path = bison_path
        self.base_dir = os.getcwd()
        self.skip_existing = skip_existing
        self.install_dir = libpack_dir(config)
        self.init_script = None

    def get_cmake_options(self) -> list[str]:
        """ Get a comprehensive list of cMake options that can be used in any cMake build. Not all options apply
        to all builds, but none conflict. """
        base = [
            f'-D BISON_EXECUTABLE={self.bison_path}',
            f'-D BOOST_ROOT={self.install_dir}',
            f'-D BUILD_DOC=No',
            f'-D BUILD_DOCS=No',
            f'-D BUILD_EXAMPLES=No',
            f'-D BUILD_SHARED=Yes',
            f'-D BUILD_SHARED_LIB=Yes',
            f'-D BUILD_SHARED_LIBS=Yes',
            f'-D BUILD_TEST=No',
            f'-D BUILD_TESTS=No',
            f'-D BUILD_TESTING=No',
            f'-D BZIP2_DIR={self.install_dir}/lib/cmake/',
            f'-D Boost_INCLUDE_DIR={self.install_dir}/include/boost-1_83/',
            f'-D Boost_INCLUDE_DIRS={self.install_dir}/include',
            f'-D CMAKE_INSTALL_PATH={self.install_dir}',
            f'-D CMAKE_INSTALL_PREFIX={self.install_dir}',
            f'-D Coin_DIR={self.install_dir}/lib/cmake/Coin-4.0.1',
            f'-D HarfBuzz_DIR={self.install_dir}/lib/cmake/',
            f'-D HDF5_DIR={self.install_dir}/share/cmake/',
            f'-D HDF5_LIBRARY_DEBUG={self.install_dir}/lib/hdf5d.lib',
            f'-D HDF5_LIBRARY_RELEASE={self.install_dir}/lib/hdf5.lib',
            f'-D HDF5_DIFF_EXECUTABLE={self.install_dir}/bin/hdf5diff' + '.exe' if sys.platform.startswith(
                'win32') else '',
            f'-D INSTALL_DIR={self.install_dir}',
            f'-D PCRE2_LIBRARY={self.install_dir}/lib/pcre2-8.lib',
            f'-D Python_ROOT_DIR={self.install_dir}/bin',
            f'-D Qt6_DIR={self.install_dir}/lib/cmake/Qt6',
            f'-D SWIG_EXECUTABLE={self.install_dir}/bin/swig' + '.exe' if sys.platform.startswith('win32') else '',
            f'-D VTK_MODULE_ENABLE_VTK_IOIOSS=NO',  # Workaround for bug in Visual Studio MSVC 143
            f'-D VTK_MODULE_ENABLE_VTK_ioss=NO',  # Workaround for bug in Visual Studio MSVC 143
            f'-D ZLIB_DIR={self.install_dir}/lib/cmake/',
            f'-D ZLIB_INCLUDE_DIR={self.install_dir}/include',
            f'-D ZLIB_LIBRARY_RELEASE={self.install_dir}/lib/zlib.' + 'lib' if sys.platform.startswith(
                'win32') else 'a',
            f'-D ZLIB_LIBRARY_DEBUG={self.install_dir}/lib/zlibd.' + 'lib' if sys.platform.startswith(
                'win32') else 'a',
        ]
        if sys.platform.startswith('win32'):
            inc_path = self.install_dir.replace('\\', '/')
            cxx_flags = f'/I{inc_path}/include /EHsc /DWIN32'
        else:
            cxx_flags = f'-I{self.install_dir}/include'
        base.append(f'-D CMAKE_CXX_FLAGS={cxx_flags}')
        return base

    def compile_all(self):
        for item in self.config["content"]:
            # All build methods are named using "build_XXX" where XXX is the name of the package in the config file
            os.chdir(item["name"])
            build_function_name = "build_" + item["name"]
            if hasattr(self, build_function_name):
                print(f"Building {item['name']}")
                build_function = getattr(self, build_function_name)
                build_function(item)
            elif "pip-install" in item:
                print(f"Installing {item['name']} with pip")
                self._build_with_pip(item)
            else:
                print(f"No '{build_function_name}' found in compile_all.py -- "
                      "did you forget to add one when adding a dependency?")
                exit(2)
            os.chdir(self.base_dir)

    def build_nonexistent(self, _=None):
        """Used for automated testing to allow easy Mock injection"""

    def build_python(self, _=None):
        """ NOTE: This doesn't install correctly, so should not be used at this time... install Python manually """
        if sys.platform.startswith("win32"):
            expected_exe_path = os.path.join(self.install_dir, "bin", "python.exe")
            if self.skip_existing and os.path.exists(expected_exe_path):
                print("Not rebuilding, instead just using existing Python in the LibPack installation path")
                return
            try:
                arch = "x64" if platform.machine() == "AMD64" else "ARM64"
                path = "amd64" if platform.machine() == "AMD64" else "arm64"
                subprocess.run(
                    [
                        self.init_script, "&",
                        "PCbuild\\build.bat",
                        "-p",
                        arch,
                        "-c",
                        "Release",
                    ],
                    check=True,
                    capture_output=True,
                )
            except subprocess.CalledProcessError as e:
                print("Python build failed")
                print(e.output.decode("utf-8"))
                exit(e.returncode)
            bin_dir = os.path.join(self.install_dir, "bin")
            lib_dir = os.path.join(bin_dir, "Lib")
            inc_dir = os.path.join(bin_dir, "Include")
            os.makedirs(bin_dir, exist_ok=True)
            os.makedirs(lib_dir, exist_ok=True)
            os.makedirs(bin_dir, exist_ok=True)
            shutil.copytree(f"PCBuild\\{path}", bin_dir, dirs_exist_ok=True)
            shutil.copytree(f"Lib", lib_dir, dirs_exist_ok=True)
            shutil.copytree(f"Include", inc_dir, dirs_exist_ok=True)
        else:
            raise NotImplemented(
                "Non-Windows compilation of Python is not implemented yet"
            )

    def get_python_version(self) -> str:
        path_to_python = os.path.join(self.install_dir, "bin", "python")
        if sys.platform.startswith("win32"):
            path_to_python += ".exe"
        try:
            result = subprocess.run([path_to_python, "--version"], capture_output=True, check=True)
            _, _, version_number = result.stdout.decode("utf-8").strip().partition(" ")
            components = version_number.split(".")
            python_version = f"{components[0]}.{components[1]}"
            return python_version
        except subprocess.CalledProcessError as e:
            print("ERROR: Failed to run LibPack's Python executable")
            print(e.output.decode("utf-8"))
            exit(1)

    def build_qt(self, options: dict):
        """Doesn't really "build" Qt, just copies the pre-compiled libraries from the configured path"""
        qt_dir = options["install-directory"]
        if self.skip_existing:
            if os.path.exists(os.path.join(self.install_dir, "metatypes")):
                print("  Not re-copying, instead just using existing Qt in the LibPack installation path")
                return
        if not os.path.exists(qt_dir):
            print(f"Error: specified Qt installation path does not exist ({qt_dir})")
            exit(1)
        print("  (Note that Qt isn't really 'built,' it is just copied from a local installation)")
        shutil.copytree(qt_dir, self.install_dir, dirs_exist_ok=True)

    def build_boost(self, _=None):
        """ Builds boost shared libraries and installs libraries and headers """
        if self.skip_existing:
            if os.path.exists(os.path.join(self.install_dir, "include", "boost-1_83")):
                print("  Not rebuilding boost, it is already in the LibPack")
                return
        # Boost uses a custom build system and needs a config file to find our Python
        with open(os.path.join("tools", "build", "src", "user-config.jam"), "w", encoding="utf-8") as user_config:
            exe = os.path.join(self.install_dir, "bin", "python")
            if sys.platform.startswith("win32"):
                exe += ".exe"
                exe = exe.replace("\\", "\\\\")
            inc_dir = os.path.join(self.install_dir, "bin", "include").replace("\\", "\\\\")
            lib_dir = os.path.join(self.install_dir, "bin", "libs").replace("\\", "\\\\")
            python_version = self.get_python_version()
            print(f"  (boost-python is being built against Python {python_version})")
            user_config.write(f'using python : {python_version} : "{exe}" : "{inc_dir}" : "{lib_dir}"  ;\n')
        try:
            # When debugging on the command line, add --debug-configuration to get more verbose output
            subprocess.run([self.init_script, "&", "bootstrap.bat"], capture_output=True, check=True)
            subprocess.run([self.init_script, "&", "b2",
                            f"install",
                            "address-model=64",
                            f"--prefix=${self.install_dir}",
                            "--layout=versioned",
                            "--build-type=complete",
                            f"stage"],
                           check=True,
                           capture_output=True)
        except subprocess.CalledProcessError as e:
            print("Error: failed to build boost")
            print(e.stdout.decode("utf-8"))
            print(e.stderr.decode("utf-8"))
            exit(e.returncode)

    def _cmake_create_build_dir(self, variant:BuildMode = BuildMode.RELEASE):
        build_dir = "build-" + str(variant).lower()
        if os.path.exists(build_dir):
            shutil.rmtree(build_dir, onerror=remove_readonly)
        os.mkdir(build_dir)
        os.chdir(build_dir)

    def _run_cmake(self, args):
        cmake_setup_options = [self.init_script, "&", "cmake"]
        cmake_setup_options.extend(args)
        try:
            subprocess.run(cmake_setup_options, check=True, capture_output=True)
        except subprocess.CalledProcessError as e:
            print("ERROR: cMake failed!")
            print (f"Command: {' '.join(cmake_setup_options)}")
            print(e.stdout.decode("utf-8"))
            print(e.stderr.decode("utf-8"))
            exit(e.returncode)

    def _cmake_configure(self, extra_args: list[str] = None):
        options = self.get_cmake_options()
        if extra_args:
            options.extend(extra_args)
        options.append("..")
        self._run_cmake(options)

    def _cmake_build(self, variant:BuildMode = BuildMode.RELEASE):
        # Not building with --parallel because even with 32gb of RAM, OpenCASCADE runs out of memory on my system
        cmake_build_options = ["--build", ".", "--config", str(variant)]
        self._run_cmake(cmake_build_options)

    def _cmake_install(self, variant:BuildMode = BuildMode.RELEASE):
        cmake_install_options = ["--install", ".", "--config", str(variant)]
        self._run_cmake(cmake_install_options)

    def _build_standard_cmake(self, extra_args: list[str] = None):
        self._cmake_create_build_dir(BuildMode.RELEASE)
        self._cmake_configure(extra_args)
        self._cmake_build(BuildMode.RELEASE)
        self._cmake_install(BuildMode.RELEASE)
        os.chdir("..")
        self._cmake_create_build_dir(BuildMode.DEBUG)
        self._cmake_configure(extra_args)
        self._cmake_build(BuildMode.DEBUG)
        self._cmake_install(BuildMode.DEBUG)
        os.chdir("..")

    def _pip_install(self, requirement: str) -> None:
        path_to_python = os.path.join(self.install_dir, "bin", "python")
        if sys.platform.startswith("win32"):
            path_to_python += ".exe"
        try:
            subprocess.run([path_to_python, "-m", "pip", "install", requirement], check=True,
                           capture_output=True)
        except subprocess.CalledProcessError as e:
            print(f"ERROR: Failed to pip install {requirement}")
            print(e.output.decode("utf-8"))
            exit(1)

    def _build_with_pip(self, options: dict):
        if "pip-install" not in options:
            print(
                f"ERROR: No pip-install provided in configuration of {options['name']}, so version cannot be determined")
            exit(1)
        self._pip_install(options["pip-install"])

    def build_coin(self, _=None):
        """ Builds and installs Coin using standard CMake settings """
        if self.skip_existing:
            if os.path.exists(os.path.join(self.install_dir, "share", "Coin")):
                print("  Not rebuilding Coin, it is already in the LibPack")
                return
        extra_args = ["-DCOIN_BUILD_TESTS=Off"]
        self._build_standard_cmake(extra_args)

    def build_quarter(self, _=None):
        """ Builds and installs Quarter using standard CMake settings """
        if self.skip_existing:
            if os.path.exists(os.path.join(self.install_dir, "include", "Quarter")):
                print("  Not rebuilding Quarter, it is already in the LibPack")
                return
        self._build_standard_cmake()

    def build_zlib(self, _=None):
        if self.skip_existing:
            if os.path.exists(os.path.join(self.install_dir, "include", "zlib.h")):
                print("  Not rebuilding zlib, it is already in the LibPack")
                return
        self._build_standard_cmake()

    def build_bzip2(self, _=None):
        """ The version of BZip2 in widespread use (1.0.8, the most recent official release) do not yet use cMake """
        if self.skip_existing:
            if os.path.exists(os.path.join(self.install_dir, "include", "bzlib.h")):
                print("  Not rebuilding bzip2, it is already in the LibPack")
                return
        if sys.platform.startswith("win32"):
            args = [self.init_script, "&", "nmake", "/f", "makefile.msc"]
            try:
                subprocess.run(args, check=True, capture_output=True)
                shutil.copyfile("libbz2.lib", os.path.join(self.install_dir, "lib", "libbz2.lib"))
                shutil.copyfile("bzlib.h", os.path.join(self.install_dir, "include", "bzlib.h"))
                shutil.copyfile("bzlib_private.h", os.path.join(self.install_dir, "include", "bzlib_private.h"))
            except subprocess.CalledProcessError as e:
                print("ERROR: Failed to build bzip2 using nmake")
                print(e.output.decode("utf-8"))
                exit(1)
        else:
            raise NotImplemented(
                "Non-Windows compilation of bzip2 is not implemented yet"
            )

    def build_pcre2(self, _=None):
        if self.skip_existing:
            if os.path.exists(os.path.join(self.install_dir, "include", "pcre2.h")):
                print("  Not rebuilding pcre2, it is already in the LibPack")
                return
        self._build_standard_cmake()

    def build_swig(self, _=None):
        if self.skip_existing:
            if os.path.exists(
                    os.path.join(self.install_dir, "bin", "swig") + ".exe" if sys.platform.startswith("win32") else ""):
                print("  Not rebuilding SWIG, it is already in the LibPack")
                return
        self._build_standard_cmake()

    def build_pivy(self, _=None):
        if self.skip_existing:
            if os.path.exists(os.path.join(self.install_dir, "bin", "Lib", "site-packages", "pivy")):
                print("  Not rebuilding pivy, it is already in the LibPack")
                return
        self._build_standard_cmake()

    def build_libclang(self, _=None):
        """ libclang is provided as a platform-specific download by Qt. """
        if self.skip_existing:
            if os.path.exists(os.path.join(self.install_dir, "include", "clang")):
                print("  Not copying libclang, it is already in the LibPack")
                return
        print("  (not really building libclang, just copying from a build provided by Qt)")
        shutil.copytree("libclang", self.install_dir, dirs_exist_ok=True)

    def build_pyside(self, options=None):
        # Don't use a pip-install for this, we need the linkable libraries and include files for both PySide and
        # Shiboken, which won't get installed by pip
        if self.skip_existing:
            if os.path.exists(os.path.join(self.install_dir, "bin", "Lib", "site-packages", "PySide6")):
                print("  Not rebuilding PySide6, it is already in the LibPack")
                return
        python = os.path.join(self.install_dir, "bin", "python")
        qtpaths = "--qtpaths=" + os.path.join(self.install_dir, "bin", "qtpaths6")
        ssl = "--openssl=" + os.path.join(self.install_dir, "bin", "DLLs")
        clang = "CLANG_INSTALL_DIR=" + os.path.join(self.install_dir, "lib", "clang")
        numpy = "--enable-numpy-support"
        if sys.platform.startswith("win32"):
            python += ".exe"
            qtpaths += ".exe"
            ssl += ".dll"
            args = [self.init_script, "&", "set", clang, "&", python, "setup.py", "build", qtpaths, ssl, numpy]
        else:
            ssl += ".so"
            args = [clang, "&&", python, "setup.py", "install", qtpaths, ssl, numpy]
        try:
            subprocess.run(args, capture_output=True, check=True)
        except subprocess.CalledProcessError as e:
            print("ERROR: Failed to build Pyside and/or Shiboken")
            print(e.stdout.decode("utf-8"))
            print(e.stderr.decode("utf-8"))
            exit(1)

    def build_vtk(self, _=None):
        if self.skip_existing:
            if os.path.exists(os.path.join(self.install_dir, "share", "licenses", "VTK")):
                print("  Not rebuilding VTK, it is already in the LibPack")
                return
        print("  (VTK is big, this will take some time)")
        self._build_standard_cmake()

    def build_harfbuzz(self, _=None):
        if self.skip_existing:
            if os.path.exists(os.path.join(self.install_dir, "include", "harfbuzz")):
                print("  Not rebuilding harfbuzz, it is already in the LibPack")
                return
        self._build_standard_cmake()

    def build_libpng(self, _=None):
        if self.skip_existing:
            if os.path.exists(os.path.join(self.install_dir, "lib", "libpng")):
                print("  Not rebuilding libpng, it is already in the LibPack")
                return
        self._build_standard_cmake()

    def build_freetype(self, _=None):
        if self.skip_existing:
            if os.path.exists(os.path.join(self.install_dir, "include", "freetype2")):
                print("  Not rebuilding freetype, it is already in the LibPack")
                return
        self._build_standard_cmake()

    def force_copy(self, src_components: list[str], dst_components: list[str]):
        full_src = self.install_dir
        for src in src_components:
            full_src = os.path.join(full_src, src)
        full_dst = self.install_dir
        for dst in dst_components:
            full_dst = os.path.join(full_dst, dst)
        if not os.path.exists(full_src):
            print(f"    (Can't rename {full_src}, no such file or directory)")
            return
        if os.path.exists(full_dst):
            os.unlink(full_dst)
        shutil.copyfile(full_src, full_dst)

    def build_tcl(self, _=None):
        """ tcl does not use cMake """
        if self.skip_existing:
            if os.path.exists(os.path.join(self.install_dir, "include", "tcl.h")):
                print("  Not rebuilding tcl, it is already in the LibPack")
                return
        if sys.platform.startswith("win32"):
            try:
                os.chdir("win")
                for variant in [BuildMode.RELEASE, BuildMode.DEBUG]:
                    args = [self.init_script, "&", "nmake", "/f", "makefile.vc", "release"]
                    if variant == BuildMode.DEBUG:
                        args.append("OPTS=symbols")
                    subprocess.run(args, check=True, capture_output=True)
                    args = [self.init_script,
                            "&",
                            "nmake",
                            "/f",
                            "makefile.vc",
                            "install",
                            f"INSTALLDIR={self.install_dir}"]
                    subprocess.run(args, check=True, capture_output=True)
                    if variant == BuildMode.RELEASE:
                        self.force_copy(["bin", "tclsh86t.exe"], ["bin", "tclsh.exe"]) # Plus some debug? TODO what are they?
                        self.force_copy(["bin", "tcl86t.dll"], ["bin", "tcl86.dll"])
                        self.force_copy(["lib", "tcl86t.lib"], ["lib", "tcl86.lib"])
                    else:
                        self.force_copy(["bin", "tclsh86t.exe"], ["bin", "tclsh_d.exe"]) # Plus some debug? TODO what are they?
                        self.force_copy(["bin", "tcl86t.dll"], ["bin", "tcl86_d.dll"])
                        self.force_copy(["lib", "tcl86t.lib"], ["lib", "tcl86_d.lib"])
            except subprocess.CalledProcessError as e:
                print("ERROR: Failed to build tcl using nmake")
                print(e.stdout.decode("utf-8"))
                print(e.stderr.decode("utf-8"))
                exit(1)
        else:
            raise NotImplemented(
                "Non-Windows compilation of tcl is not implemented yet"
            )

    def build_tk(self, _=None):
        """ tk does not use cMake """
        if self.skip_existing:
            if os.path.exists(os.path.join(self.install_dir, "include", "tk.h")):
                print("  Not rebuilding tk, it is already in the LibPack")
                return
        if sys.platform.startswith("win32"):
            try:
                os.chdir("win")
                for variant in [BuildMode.RELEASE, BuildMode.DEBUG]:
                    args = [self.init_script, "&", "nmake", "/f", "makefile.vc", "release"]
                    if variant == BuildMode.DEBUG:
                        args.append("OPTS=symbols")
                    subprocess.run(args, check=True, capture_output=True)
                    args = [self.init_script, "&", "nmake", "/f", "makefile.vc ", "install",
                            f"INSTALLDIR={self.install_dir}"]
                    subprocess.run(args, check=True, capture_output=True)
                    if variant == BuildMode.RELEASE:
                        self.force_copy(["bin", "wish86t.exe"], ["bin", "wish.exe"])  # Plus some debug? TODO what are they?
                        self.force_copy(["bin", "tk86t.dll"], ["bin", "tk86.dll"])
                        self.force_copy(["lib", "tk86t.lib"], ["lib", "tk86.lib"])
                    else:
                        self.force_copy(["bin", "wish86t.exe"], ["bin", "wish_d.exe"])  # Plus some debug? TODO what are they?
                        self.force_copy(["bin", "tk86t.dll"], ["bin", "tk86_d.dll"])
                        self.force_copy(["lib", "tk86t.lib"], ["lib", "tk86_d.lib"])
            except subprocess.CalledProcessError as e:
                print("ERROR: Failed to build tk using nmake")
                print(e.output.decode("utf-8"))
                exit(1)
        else:
            raise NotImplemented(
                "Non-Windows compilation of tk is not implemented yet"
            )

    def build_rapidjson(self, _):
        if os.path.exists(os.path.join(self.install_dir, "include", "rapidjson")):
            if self.skip_existing:
                print("  Not re-copying RapidJSON, it is already in the LibPack")
                return
            shutil.rmtree(os.path.join(self.install_dir, "include", "rapidjson"))
        shutil.copytree("include", os.path.join(self.install_dir, "include"), dirs_exist_ok=True)

    def build_opencascade(self, _=None):
        if self.skip_existing:
            if os.path.exists(os.path.join(self.install_dir, "cmake", "OpenCASCADEConfig.cmake")):
                print("  Not rebuilding OpenCASCADE, it is already in the LibPack")
                return
        for variant in [BuildMode.RELEASE, BuildMode.DEBUG]:
            extra_args = [f"-D 3RDPARTY_DIR={self.install_dir}",
                          f"-D 3RDPARTY_VTK_INCLUDE_DIR={self.install_dir}/include/vtk-9.2",  # TODO: Remove hardcoded 9.2
                          f"-D USE_VTK=On",
                          f"-D USE_RAPIDJSON=On",
                          f"-D BUILD_CPP_STANDARD=C++17",
                          f"-DBUILD_RELEASE_DISABLE_EXCEPTIONS=OFF",
                          f"-DINSTALL_DIR_BIN=bin",
                          f"-DINSTALL_DIR_LIB=lib"]
            if variant == BuildMode.DEBUG:
                extra_args.append("-DBUILD_SHARED_LIBRARY_NAME_POSTFIX=d")
            cwd = os.getcwd()
            self._cmake_create_build_dir(variant)
            self._cmake_configure(extra_args)
            self._cmake_build(variant)
            if variant == BuildMode.DEBUG and sys.platform.startswith("win32"):
                # On Windows OpenCASCADE is looking in the wrong location for these files (as of 7.7.1) -- just copy them
                # TODO - Don't hardcode the path
                shutil.copytree(os.path.join("win64", "vc14", "bind"), os.path.join("win64", "vc14", "bin"))
            self._cmake_install()
            os.chdir(cwd)

    def build_netgen(self, _: None):
        if self.skip_existing:
            if os.path.exists(os.path.join(self.install_dir, "share", "netgen")):
                print("  Not rebuilding netgen, it is already in the LibPack")
                return
        extra_args = [f"-DCMAKE_FIND_ROOT_PATH={self.install_dir}",
                      "-D USE_SUPERBUILD=OFF",
                      "-D USE_GUI=OFF",
                      "-D USE_NATIVE_ARCH=OFF",
                      "-D USE_INTERNAL_TCL=OFF",
                      f"-D TCL_DIR={self.install_dir}",
                      f"-D TK_DIR={self.install_dir}",
                      "-D USE_OCC=On",
                      f"-D OpenCASCADE_ROOT={self.install_dir}",
                      f"-D USE_PYTHON=OFF"]
        self._build_standard_cmake(extra_args=extra_args)

    def build_hdf5(self, _: None):
        if self.skip_existing:
            if os.path.exists(os.path.join(self.install_dir, "include", "hdf5.h")):
                print("  Not rebuilding hdf5, it is already in the LibPack")
                return
        # Something goes wrong with the install during this script, but when run from the command line it succeeds
        # without a problem.
        self._build_standard_cmake()

    def build_medfile(self, _: None):
        if self.skip_existing:
            if os.path.exists(os.path.join(self.install_dir, "include", "medfile.h")):
                print("  Not rebuilding medfile, it is already in the LibPack")
                return
        extra_args = ["-DMEDFILE_USE_UNICODE=On"]
        self._build_standard_cmake(extra_args)

    def build_gmsh(self, _: None):
        if self.skip_existing:
            if os.path.exists(
                    os.path.join(self.install_dir,
                                 "bin",
                                 "gmsh" + ".exe" if sys.platform.startswith("win32") else "")):
                print("  Not rebuilding gmsh, it is already in the LibPack")
                return
        extra_args = []
        if sys.platform.startswith("win32"):
            extra_args = [f"-D CMAKE_LIBRARY_PATH={self.install_dir}/win64/vc14/lib",  # TODO - Remove hardcoding
                          "-D ENABLE_OPENMP=No"]  # Build fails if OpenMP is enabled
        self._build_standard_cmake(extra_args)

    def build_pycxx(self, _: None):
        """ PyCXX does not use a cMake-based build system """
        if self.skip_existing:
            if os.path.exists(os.path.join(self.install_dir, "bin", "Lib", "site-packages", "CXX")):
                print("  Not rebuilding PyCXX, it is already in the LibPack")
                return
        path_to_python = os.path.join(self.install_dir, "bin", "python")
        if sys.platform.startswith("win32"):
            path_to_python += ".exe"
        args = [path_to_python, "setup.py", "install"]
        try:
            subprocess.run(args, check=True, capture_output=True)
        except subprocess.CalledProcessError as e:
            print("ERROR: Failed to build PyCXX using its custom build script")
            print(e.output.decode("utf-8"))
            exit(1)

    def build_icu(self, _: None):
        """ ICU does not use cMake, but has projects for various OSes """
        if self.skip_existing:
            if os.path.exists(os.path.join(self.install_dir, "include", "unicode")):
                print("  Not rebuilding ICU, it is already in the LibPack")
                return

        os.chdir(os.path.join("icu4c", "source"))
        if sys.platform.startswith("win32"):
            os.chdir("allinone")
            for variant in ["Release", "Debug"]:
                args = [self.init_script, "&", "msbuild", f"/p:Configuration={variant}",
                        "/t:Build", "/p:SkipUWP=true", "allinone.sln"]
                subprocess.run(args, check=True, capture_output=True)
            os.chdir(os.path.join("..", ".."))
            bin_dir = os.path.join(self.install_dir, "bin")
            lib_dir = os.path.join(self.install_dir, "lib")
            inc_dir = os.path.join(self.install_dir, "include")
            shutil.copytree(f"bin64", bin_dir, dirs_exist_ok=True)
            shutil.copytree(f"lib64", lib_dir, dirs_exist_ok=True)
            shutil.copytree(f"include", inc_dir, dirs_exist_ok=True)
        else:
            raise NotImplemented(
                "Non-Windows compilation of ICU is not implemented yet"
            )

    def build_xercesc(self, _: None):
        if self.skip_existing:
            if os.path.exists(os.path.join(self.install_dir, "include", "xercesc")):
                print("  Not rebuilding xerces-c, it is already in the LibPack")
                return
        extra_args = [f"-D ICU_INCLUDE_DIR={self.install_dir}/include/unicode",
                      f"-D ICU_ROOT={self.install_dir}",
                      f"-D ICU_UC_DIR={self.install_dir}"]
        self._build_standard_cmake(extra_args)

    def build_libfmt(self, _: None):
        if self.skip_existing:
            if os.path.exists(os.path.join(self.install_dir, "include", "fmt")):
                print("  Not rebuilding libfmt, it is already in the LibPack")
                return
        self._build_standard_cmake()

    def build_eigen3(self, _: None):
        if self.skip_existing:
            if os.path.exists(os.path.join(self.install_dir, "include", "eigen3")):
                print("  Not rebuilding Eigen3, it is already in the LibPack")
                return
        self._build_standard_cmake()

    def build_yamlcpp(self, _: None):
        if self.skip_existing:
            if os.path.exists(os.path.join(self.install_dir, "include", "yaml-cpp")):
                print("  Not rebuilding yaml-cpp, it is already in the LibPack")
                return
        extra_args = ["-D YAML_BUILD_SHARED_LIBS=ON"]
        self._build_standard_cmake((extra_args))
